Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    or

Grammar

Rule 0     S' -> Main
Rule 1     Main -> Instrucoes
Rule 2     Instrucoes -> Instrucoes Instrucao
Rule 3     Instrucoes -> Instrucao
Rule 4     Instrucao -> Atr
Rule 5     Instrucao -> repeat { Instrucoes } until ( Conds )
Rule 6     Instrucao -> if ( Conds ) { Instrucoes }
Rule 7     Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes }
Rule 8     Conds -> Conds and Cond
Rule 9     Conds -> Cond
Rule 10    Cond -> Exp < Exp
Rule 11    Cond -> Exp > Exp
Rule 12    Cond -> Exp = = Exp
Rule 13    Cond -> Exp < = Exp
Rule 14    Cond -> Exp > = Exp
Rule 15    Cond -> Exp ! = Exp
Rule 16    Atr -> id = Exp
Rule 17    Atr -> array ( id , int )
Rule 18    Atr -> id [ int ] = Exp
Rule 19    Atr -> id [ id ] = Exp
Rule 20    Atr -> $ string
Rule 21    Atr -> $ int
Rule 22    Atr -> $
Rule 23    Exp -> Exp + Term
Rule 24    Term -> Term - Factor
Rule 25    Exp -> Term
Rule 26    Term -> Term * Factor
Rule 27    Term -> Term / Factor
Rule 28    Term -> Factor
Rule 29    Factor -> id
Rule 30    Factor -> int
Rule 31    Factor -> float
Rule 32    Factor -> string

Terminals, with rules where they appear

!                    : 15
$                    : 20 21 22
(                    : 5 6 7 17
)                    : 5 6 7 17
*                    : 26
+                    : 23
,                    : 17
-                    : 24
/                    : 27
<                    : 10 13
=                    : 12 12 13 14 15 16 18 19
>                    : 11 14
[                    : 18 19
]                    : 18 19
and                  : 8
array                : 17
else                 : 7
error                : 
float                : 31
id                   : 16 17 18 19 19 29
if                   : 6 7
int                  : 17 18 21 30
or                   : 
repeat               : 5
string               : 20 32
until                : 5
{                    : 5 6 7 7
}                    : 5 6 7 7

Nonterminals, with rules where they appear

Atr                  : 4
Cond                 : 8 9
Conds                : 5 6 7 8
Exp                  : 10 10 11 11 12 12 13 13 14 14 15 15 16 18 19 23
Factor               : 24 26 27 28
Instrucao            : 2 3
Instrucoes           : 1 2 5 6 7 7
Main                 : 0
Term                 : 23 24 25 26 27

Parsing method: LALR

state 0

    (0) S' -> . Main
    (1) Main -> . Instrucoes
    (2) Instrucoes -> . Instrucoes Instrucao
    (3) Instrucoes -> . Instrucao
    (4) Instrucao -> . Atr
    (5) Instrucao -> . repeat { Instrucoes } until ( Conds )
    (6) Instrucao -> . if ( Conds ) { Instrucoes }
    (7) Instrucao -> . if ( Conds ) { Instrucoes } else { Instrucoes }
    (16) Atr -> . id = Exp
    (17) Atr -> . array ( id , int )
    (18) Atr -> . id [ int ] = Exp
    (19) Atr -> . id [ id ] = Exp
    (20) Atr -> . $ string
    (21) Atr -> . $ int
    (22) Atr -> . $

    repeat          shift and go to state 5
    if              shift and go to state 6
    id              shift and go to state 7
    array           shift and go to state 8
    $               shift and go to state 9

    Main                           shift and go to state 1
    Instrucoes                     shift and go to state 2
    Instrucao                      shift and go to state 3
    Atr                            shift and go to state 4

state 1

    (0) S' -> Main .



state 2

    (1) Main -> Instrucoes .
    (2) Instrucoes -> Instrucoes . Instrucao
    (4) Instrucao -> . Atr
    (5) Instrucao -> . repeat { Instrucoes } until ( Conds )
    (6) Instrucao -> . if ( Conds ) { Instrucoes }
    (7) Instrucao -> . if ( Conds ) { Instrucoes } else { Instrucoes }
    (16) Atr -> . id = Exp
    (17) Atr -> . array ( id , int )
    (18) Atr -> . id [ int ] = Exp
    (19) Atr -> . id [ id ] = Exp
    (20) Atr -> . $ string
    (21) Atr -> . $ int
    (22) Atr -> . $

    $end            reduce using rule 1 (Main -> Instrucoes .)
    repeat          shift and go to state 5
    if              shift and go to state 6
    id              shift and go to state 7
    array           shift and go to state 8
    $               shift and go to state 9

    Instrucao                      shift and go to state 10
    Atr                            shift and go to state 4

state 3

    (3) Instrucoes -> Instrucao .

    repeat          reduce using rule 3 (Instrucoes -> Instrucao .)
    if              reduce using rule 3 (Instrucoes -> Instrucao .)
    id              reduce using rule 3 (Instrucoes -> Instrucao .)
    array           reduce using rule 3 (Instrucoes -> Instrucao .)
    $               reduce using rule 3 (Instrucoes -> Instrucao .)
    $end            reduce using rule 3 (Instrucoes -> Instrucao .)
    }               reduce using rule 3 (Instrucoes -> Instrucao .)


state 4

    (4) Instrucao -> Atr .

    repeat          reduce using rule 4 (Instrucao -> Atr .)
    if              reduce using rule 4 (Instrucao -> Atr .)
    id              reduce using rule 4 (Instrucao -> Atr .)
    array           reduce using rule 4 (Instrucao -> Atr .)
    $               reduce using rule 4 (Instrucao -> Atr .)
    $end            reduce using rule 4 (Instrucao -> Atr .)
    }               reduce using rule 4 (Instrucao -> Atr .)


state 5

    (5) Instrucao -> repeat . { Instrucoes } until ( Conds )

    {               shift and go to state 11


state 6

    (6) Instrucao -> if . ( Conds ) { Instrucoes }
    (7) Instrucao -> if . ( Conds ) { Instrucoes } else { Instrucoes }

    (               shift and go to state 12


state 7

    (16) Atr -> id . = Exp
    (18) Atr -> id . [ int ] = Exp
    (19) Atr -> id . [ id ] = Exp

    =               shift and go to state 13
    [               shift and go to state 14


state 8

    (17) Atr -> array . ( id , int )

    (               shift and go to state 15


state 9

    (20) Atr -> $ . string
    (21) Atr -> $ . int
    (22) Atr -> $ .

    string          shift and go to state 16
    int             shift and go to state 17
    repeat          reduce using rule 22 (Atr -> $ .)
    if              reduce using rule 22 (Atr -> $ .)
    id              reduce using rule 22 (Atr -> $ .)
    array           reduce using rule 22 (Atr -> $ .)
    $               reduce using rule 22 (Atr -> $ .)
    $end            reduce using rule 22 (Atr -> $ .)
    }               reduce using rule 22 (Atr -> $ .)


state 10

    (2) Instrucoes -> Instrucoes Instrucao .

    repeat          reduce using rule 2 (Instrucoes -> Instrucoes Instrucao .)
    if              reduce using rule 2 (Instrucoes -> Instrucoes Instrucao .)
    id              reduce using rule 2 (Instrucoes -> Instrucoes Instrucao .)
    array           reduce using rule 2 (Instrucoes -> Instrucoes Instrucao .)
    $               reduce using rule 2 (Instrucoes -> Instrucoes Instrucao .)
    $end            reduce using rule 2 (Instrucoes -> Instrucoes Instrucao .)
    }               reduce using rule 2 (Instrucoes -> Instrucoes Instrucao .)


state 11

    (5) Instrucao -> repeat { . Instrucoes } until ( Conds )
    (2) Instrucoes -> . Instrucoes Instrucao
    (3) Instrucoes -> . Instrucao
    (4) Instrucao -> . Atr
    (5) Instrucao -> . repeat { Instrucoes } until ( Conds )
    (6) Instrucao -> . if ( Conds ) { Instrucoes }
    (7) Instrucao -> . if ( Conds ) { Instrucoes } else { Instrucoes }
    (16) Atr -> . id = Exp
    (17) Atr -> . array ( id , int )
    (18) Atr -> . id [ int ] = Exp
    (19) Atr -> . id [ id ] = Exp
    (20) Atr -> . $ string
    (21) Atr -> . $ int
    (22) Atr -> . $

    repeat          shift and go to state 5
    if              shift and go to state 6
    id              shift and go to state 7
    array           shift and go to state 8
    $               shift and go to state 9

    Instrucoes                     shift and go to state 18
    Instrucao                      shift and go to state 3
    Atr                            shift and go to state 4

state 12

    (6) Instrucao -> if ( . Conds ) { Instrucoes }
    (7) Instrucao -> if ( . Conds ) { Instrucoes } else { Instrucoes }
    (8) Conds -> . Conds and Cond
    (9) Conds -> . Cond
    (10) Cond -> . Exp < Exp
    (11) Cond -> . Exp > Exp
    (12) Cond -> . Exp = = Exp
    (13) Cond -> . Exp < = Exp
    (14) Cond -> . Exp > = Exp
    (15) Cond -> . Exp ! = Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Conds                          shift and go to state 19
    Cond                           shift and go to state 20
    Exp                            shift and go to state 21
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 13

    (16) Atr -> id = . Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 28
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 14

    (18) Atr -> id [ . int ] = Exp
    (19) Atr -> id [ . id ] = Exp

    int             shift and go to state 30
    id              shift and go to state 29


state 15

    (17) Atr -> array ( . id , int )

    id              shift and go to state 31


state 16

    (20) Atr -> $ string .

    repeat          reduce using rule 20 (Atr -> $ string .)
    if              reduce using rule 20 (Atr -> $ string .)
    id              reduce using rule 20 (Atr -> $ string .)
    array           reduce using rule 20 (Atr -> $ string .)
    $               reduce using rule 20 (Atr -> $ string .)
    $end            reduce using rule 20 (Atr -> $ string .)
    }               reduce using rule 20 (Atr -> $ string .)


state 17

    (21) Atr -> $ int .

    repeat          reduce using rule 21 (Atr -> $ int .)
    if              reduce using rule 21 (Atr -> $ int .)
    id              reduce using rule 21 (Atr -> $ int .)
    array           reduce using rule 21 (Atr -> $ int .)
    $               reduce using rule 21 (Atr -> $ int .)
    $end            reduce using rule 21 (Atr -> $ int .)
    }               reduce using rule 21 (Atr -> $ int .)


state 18

    (5) Instrucao -> repeat { Instrucoes . } until ( Conds )
    (2) Instrucoes -> Instrucoes . Instrucao
    (4) Instrucao -> . Atr
    (5) Instrucao -> . repeat { Instrucoes } until ( Conds )
    (6) Instrucao -> . if ( Conds ) { Instrucoes }
    (7) Instrucao -> . if ( Conds ) { Instrucoes } else { Instrucoes }
    (16) Atr -> . id = Exp
    (17) Atr -> . array ( id , int )
    (18) Atr -> . id [ int ] = Exp
    (19) Atr -> . id [ id ] = Exp
    (20) Atr -> . $ string
    (21) Atr -> . $ int
    (22) Atr -> . $

    }               shift and go to state 32
    repeat          shift and go to state 5
    if              shift and go to state 6
    id              shift and go to state 7
    array           shift and go to state 8
    $               shift and go to state 9

    Instrucao                      shift and go to state 10
    Atr                            shift and go to state 4

state 19

    (6) Instrucao -> if ( Conds . ) { Instrucoes }
    (7) Instrucao -> if ( Conds . ) { Instrucoes } else { Instrucoes }
    (8) Conds -> Conds . and Cond

    )               shift and go to state 33
    and             shift and go to state 34


state 20

    (9) Conds -> Cond .

    )               reduce using rule 9 (Conds -> Cond .)
    and             reduce using rule 9 (Conds -> Cond .)


state 21

    (10) Cond -> Exp . < Exp
    (11) Cond -> Exp . > Exp
    (12) Cond -> Exp . = = Exp
    (13) Cond -> Exp . < = Exp
    (14) Cond -> Exp . > = Exp
    (15) Cond -> Exp . ! = Exp
    (23) Exp -> Exp . + Term

    <               shift and go to state 35
    >               shift and go to state 36
    =               shift and go to state 37
    !               shift and go to state 38
    +               shift and go to state 39


state 22

    (25) Exp -> Term .
    (24) Term -> Term . - Factor
    (26) Term -> Term . * Factor
    (27) Term -> Term . / Factor

    <               reduce using rule 25 (Exp -> Term .)
    >               reduce using rule 25 (Exp -> Term .)
    =               reduce using rule 25 (Exp -> Term .)
    !               reduce using rule 25 (Exp -> Term .)
    +               reduce using rule 25 (Exp -> Term .)
    repeat          reduce using rule 25 (Exp -> Term .)
    if              reduce using rule 25 (Exp -> Term .)
    id              reduce using rule 25 (Exp -> Term .)
    array           reduce using rule 25 (Exp -> Term .)
    $               reduce using rule 25 (Exp -> Term .)
    $end            reduce using rule 25 (Exp -> Term .)
    }               reduce using rule 25 (Exp -> Term .)
    )               reduce using rule 25 (Exp -> Term .)
    and             reduce using rule 25 (Exp -> Term .)
    -               shift and go to state 40
    *               shift and go to state 41
    /               shift and go to state 42


state 23

    (28) Term -> Factor .

    -               reduce using rule 28 (Term -> Factor .)
    *               reduce using rule 28 (Term -> Factor .)
    /               reduce using rule 28 (Term -> Factor .)
    <               reduce using rule 28 (Term -> Factor .)
    >               reduce using rule 28 (Term -> Factor .)
    =               reduce using rule 28 (Term -> Factor .)
    !               reduce using rule 28 (Term -> Factor .)
    +               reduce using rule 28 (Term -> Factor .)
    repeat          reduce using rule 28 (Term -> Factor .)
    if              reduce using rule 28 (Term -> Factor .)
    id              reduce using rule 28 (Term -> Factor .)
    array           reduce using rule 28 (Term -> Factor .)
    $               reduce using rule 28 (Term -> Factor .)
    $end            reduce using rule 28 (Term -> Factor .)
    }               reduce using rule 28 (Term -> Factor .)
    )               reduce using rule 28 (Term -> Factor .)
    and             reduce using rule 28 (Term -> Factor .)


state 24

    (29) Factor -> id .

    -               reduce using rule 29 (Factor -> id .)
    *               reduce using rule 29 (Factor -> id .)
    /               reduce using rule 29 (Factor -> id .)
    <               reduce using rule 29 (Factor -> id .)
    >               reduce using rule 29 (Factor -> id .)
    =               reduce using rule 29 (Factor -> id .)
    !               reduce using rule 29 (Factor -> id .)
    +               reduce using rule 29 (Factor -> id .)
    repeat          reduce using rule 29 (Factor -> id .)
    if              reduce using rule 29 (Factor -> id .)
    id              reduce using rule 29 (Factor -> id .)
    array           reduce using rule 29 (Factor -> id .)
    $               reduce using rule 29 (Factor -> id .)
    $end            reduce using rule 29 (Factor -> id .)
    }               reduce using rule 29 (Factor -> id .)
    )               reduce using rule 29 (Factor -> id .)
    and             reduce using rule 29 (Factor -> id .)


state 25

    (30) Factor -> int .

    -               reduce using rule 30 (Factor -> int .)
    *               reduce using rule 30 (Factor -> int .)
    /               reduce using rule 30 (Factor -> int .)
    <               reduce using rule 30 (Factor -> int .)
    >               reduce using rule 30 (Factor -> int .)
    =               reduce using rule 30 (Factor -> int .)
    !               reduce using rule 30 (Factor -> int .)
    +               reduce using rule 30 (Factor -> int .)
    repeat          reduce using rule 30 (Factor -> int .)
    if              reduce using rule 30 (Factor -> int .)
    id              reduce using rule 30 (Factor -> int .)
    array           reduce using rule 30 (Factor -> int .)
    $               reduce using rule 30 (Factor -> int .)
    $end            reduce using rule 30 (Factor -> int .)
    }               reduce using rule 30 (Factor -> int .)
    )               reduce using rule 30 (Factor -> int .)
    and             reduce using rule 30 (Factor -> int .)


state 26

    (31) Factor -> float .

    -               reduce using rule 31 (Factor -> float .)
    *               reduce using rule 31 (Factor -> float .)
    /               reduce using rule 31 (Factor -> float .)
    <               reduce using rule 31 (Factor -> float .)
    >               reduce using rule 31 (Factor -> float .)
    =               reduce using rule 31 (Factor -> float .)
    !               reduce using rule 31 (Factor -> float .)
    +               reduce using rule 31 (Factor -> float .)
    repeat          reduce using rule 31 (Factor -> float .)
    if              reduce using rule 31 (Factor -> float .)
    id              reduce using rule 31 (Factor -> float .)
    array           reduce using rule 31 (Factor -> float .)
    $               reduce using rule 31 (Factor -> float .)
    $end            reduce using rule 31 (Factor -> float .)
    }               reduce using rule 31 (Factor -> float .)
    )               reduce using rule 31 (Factor -> float .)
    and             reduce using rule 31 (Factor -> float .)


state 27

    (32) Factor -> string .

    -               reduce using rule 32 (Factor -> string .)
    *               reduce using rule 32 (Factor -> string .)
    /               reduce using rule 32 (Factor -> string .)
    <               reduce using rule 32 (Factor -> string .)
    >               reduce using rule 32 (Factor -> string .)
    =               reduce using rule 32 (Factor -> string .)
    !               reduce using rule 32 (Factor -> string .)
    +               reduce using rule 32 (Factor -> string .)
    repeat          reduce using rule 32 (Factor -> string .)
    if              reduce using rule 32 (Factor -> string .)
    id              reduce using rule 32 (Factor -> string .)
    array           reduce using rule 32 (Factor -> string .)
    $               reduce using rule 32 (Factor -> string .)
    $end            reduce using rule 32 (Factor -> string .)
    }               reduce using rule 32 (Factor -> string .)
    )               reduce using rule 32 (Factor -> string .)
    and             reduce using rule 32 (Factor -> string .)


state 28

    (16) Atr -> id = Exp .
    (23) Exp -> Exp . + Term

    repeat          reduce using rule 16 (Atr -> id = Exp .)
    if              reduce using rule 16 (Atr -> id = Exp .)
    id              reduce using rule 16 (Atr -> id = Exp .)
    array           reduce using rule 16 (Atr -> id = Exp .)
    $               reduce using rule 16 (Atr -> id = Exp .)
    $end            reduce using rule 16 (Atr -> id = Exp .)
    }               reduce using rule 16 (Atr -> id = Exp .)
    +               shift and go to state 39


state 29

    (19) Atr -> id [ id . ] = Exp

    ]               shift and go to state 43


state 30

    (18) Atr -> id [ int . ] = Exp

    ]               shift and go to state 44


state 31

    (17) Atr -> array ( id . , int )

    ,               shift and go to state 45


state 32

    (5) Instrucao -> repeat { Instrucoes } . until ( Conds )

    until           shift and go to state 46


state 33

    (6) Instrucao -> if ( Conds ) . { Instrucoes }
    (7) Instrucao -> if ( Conds ) . { Instrucoes } else { Instrucoes }

    {               shift and go to state 47


state 34

    (8) Conds -> Conds and . Cond
    (10) Cond -> . Exp < Exp
    (11) Cond -> . Exp > Exp
    (12) Cond -> . Exp = = Exp
    (13) Cond -> . Exp < = Exp
    (14) Cond -> . Exp > = Exp
    (15) Cond -> . Exp ! = Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Cond                           shift and go to state 48
    Exp                            shift and go to state 21
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 35

    (10) Cond -> Exp < . Exp
    (13) Cond -> Exp < . = Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    =               shift and go to state 50
    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 49
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 36

    (11) Cond -> Exp > . Exp
    (14) Cond -> Exp > . = Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    =               shift and go to state 52
    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 51
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 37

    (12) Cond -> Exp = . = Exp

    =               shift and go to state 53


state 38

    (15) Cond -> Exp ! . = Exp

    =               shift and go to state 54


state 39

    (23) Exp -> Exp + . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Term                           shift and go to state 55
    Factor                         shift and go to state 23

state 40

    (24) Term -> Term - . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Factor                         shift and go to state 56

state 41

    (26) Term -> Term * . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Factor                         shift and go to state 57

state 42

    (27) Term -> Term / . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Factor                         shift and go to state 58

state 43

    (19) Atr -> id [ id ] . = Exp

    =               shift and go to state 59


state 44

    (18) Atr -> id [ int ] . = Exp

    =               shift and go to state 60


state 45

    (17) Atr -> array ( id , . int )

    int             shift and go to state 61


state 46

    (5) Instrucao -> repeat { Instrucoes } until . ( Conds )

    (               shift and go to state 62


state 47

    (6) Instrucao -> if ( Conds ) { . Instrucoes }
    (7) Instrucao -> if ( Conds ) { . Instrucoes } else { Instrucoes }
    (2) Instrucoes -> . Instrucoes Instrucao
    (3) Instrucoes -> . Instrucao
    (4) Instrucao -> . Atr
    (5) Instrucao -> . repeat { Instrucoes } until ( Conds )
    (6) Instrucao -> . if ( Conds ) { Instrucoes }
    (7) Instrucao -> . if ( Conds ) { Instrucoes } else { Instrucoes }
    (16) Atr -> . id = Exp
    (17) Atr -> . array ( id , int )
    (18) Atr -> . id [ int ] = Exp
    (19) Atr -> . id [ id ] = Exp
    (20) Atr -> . $ string
    (21) Atr -> . $ int
    (22) Atr -> . $

    repeat          shift and go to state 5
    if              shift and go to state 6
    id              shift and go to state 7
    array           shift and go to state 8
    $               shift and go to state 9

    Instrucoes                     shift and go to state 63
    Instrucao                      shift and go to state 3
    Atr                            shift and go to state 4

state 48

    (8) Conds -> Conds and Cond .

    )               reduce using rule 8 (Conds -> Conds and Cond .)
    and             reduce using rule 8 (Conds -> Conds and Cond .)


state 49

    (10) Cond -> Exp < Exp .
    (23) Exp -> Exp . + Term

    )               reduce using rule 10 (Cond -> Exp < Exp .)
    and             reduce using rule 10 (Cond -> Exp < Exp .)
    +               shift and go to state 39


state 50

    (13) Cond -> Exp < = . Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 64
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 51

    (11) Cond -> Exp > Exp .
    (23) Exp -> Exp . + Term

    )               reduce using rule 11 (Cond -> Exp > Exp .)
    and             reduce using rule 11 (Cond -> Exp > Exp .)
    +               shift and go to state 39


state 52

    (14) Cond -> Exp > = . Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 65
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 53

    (12) Cond -> Exp = = . Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 66
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 54

    (15) Cond -> Exp ! = . Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 67
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 55

    (23) Exp -> Exp + Term .
    (24) Term -> Term . - Factor
    (26) Term -> Term . * Factor
    (27) Term -> Term . / Factor

    <               reduce using rule 23 (Exp -> Exp + Term .)
    >               reduce using rule 23 (Exp -> Exp + Term .)
    =               reduce using rule 23 (Exp -> Exp + Term .)
    !               reduce using rule 23 (Exp -> Exp + Term .)
    +               reduce using rule 23 (Exp -> Exp + Term .)
    repeat          reduce using rule 23 (Exp -> Exp + Term .)
    if              reduce using rule 23 (Exp -> Exp + Term .)
    id              reduce using rule 23 (Exp -> Exp + Term .)
    array           reduce using rule 23 (Exp -> Exp + Term .)
    $               reduce using rule 23 (Exp -> Exp + Term .)
    $end            reduce using rule 23 (Exp -> Exp + Term .)
    }               reduce using rule 23 (Exp -> Exp + Term .)
    )               reduce using rule 23 (Exp -> Exp + Term .)
    and             reduce using rule 23 (Exp -> Exp + Term .)
    -               shift and go to state 40
    *               shift and go to state 41
    /               shift and go to state 42


state 56

    (24) Term -> Term - Factor .

    -               reduce using rule 24 (Term -> Term - Factor .)
    *               reduce using rule 24 (Term -> Term - Factor .)
    /               reduce using rule 24 (Term -> Term - Factor .)
    <               reduce using rule 24 (Term -> Term - Factor .)
    >               reduce using rule 24 (Term -> Term - Factor .)
    =               reduce using rule 24 (Term -> Term - Factor .)
    !               reduce using rule 24 (Term -> Term - Factor .)
    +               reduce using rule 24 (Term -> Term - Factor .)
    repeat          reduce using rule 24 (Term -> Term - Factor .)
    if              reduce using rule 24 (Term -> Term - Factor .)
    id              reduce using rule 24 (Term -> Term - Factor .)
    array           reduce using rule 24 (Term -> Term - Factor .)
    $               reduce using rule 24 (Term -> Term - Factor .)
    $end            reduce using rule 24 (Term -> Term - Factor .)
    }               reduce using rule 24 (Term -> Term - Factor .)
    )               reduce using rule 24 (Term -> Term - Factor .)
    and             reduce using rule 24 (Term -> Term - Factor .)


state 57

    (26) Term -> Term * Factor .

    -               reduce using rule 26 (Term -> Term * Factor .)
    *               reduce using rule 26 (Term -> Term * Factor .)
    /               reduce using rule 26 (Term -> Term * Factor .)
    <               reduce using rule 26 (Term -> Term * Factor .)
    >               reduce using rule 26 (Term -> Term * Factor .)
    =               reduce using rule 26 (Term -> Term * Factor .)
    !               reduce using rule 26 (Term -> Term * Factor .)
    +               reduce using rule 26 (Term -> Term * Factor .)
    repeat          reduce using rule 26 (Term -> Term * Factor .)
    if              reduce using rule 26 (Term -> Term * Factor .)
    id              reduce using rule 26 (Term -> Term * Factor .)
    array           reduce using rule 26 (Term -> Term * Factor .)
    $               reduce using rule 26 (Term -> Term * Factor .)
    $end            reduce using rule 26 (Term -> Term * Factor .)
    }               reduce using rule 26 (Term -> Term * Factor .)
    )               reduce using rule 26 (Term -> Term * Factor .)
    and             reduce using rule 26 (Term -> Term * Factor .)


state 58

    (27) Term -> Term / Factor .

    -               reduce using rule 27 (Term -> Term / Factor .)
    *               reduce using rule 27 (Term -> Term / Factor .)
    /               reduce using rule 27 (Term -> Term / Factor .)
    <               reduce using rule 27 (Term -> Term / Factor .)
    >               reduce using rule 27 (Term -> Term / Factor .)
    =               reduce using rule 27 (Term -> Term / Factor .)
    !               reduce using rule 27 (Term -> Term / Factor .)
    +               reduce using rule 27 (Term -> Term / Factor .)
    repeat          reduce using rule 27 (Term -> Term / Factor .)
    if              reduce using rule 27 (Term -> Term / Factor .)
    id              reduce using rule 27 (Term -> Term / Factor .)
    array           reduce using rule 27 (Term -> Term / Factor .)
    $               reduce using rule 27 (Term -> Term / Factor .)
    $end            reduce using rule 27 (Term -> Term / Factor .)
    }               reduce using rule 27 (Term -> Term / Factor .)
    )               reduce using rule 27 (Term -> Term / Factor .)
    and             reduce using rule 27 (Term -> Term / Factor .)


state 59

    (19) Atr -> id [ id ] = . Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 68
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 60

    (18) Atr -> id [ int ] = . Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Exp                            shift and go to state 69
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 61

    (17) Atr -> array ( id , int . )

    )               shift and go to state 70


state 62

    (5) Instrucao -> repeat { Instrucoes } until ( . Conds )
    (8) Conds -> . Conds and Cond
    (9) Conds -> . Cond
    (10) Cond -> . Exp < Exp
    (11) Cond -> . Exp > Exp
    (12) Cond -> . Exp = = Exp
    (13) Cond -> . Exp < = Exp
    (14) Cond -> . Exp > = Exp
    (15) Cond -> . Exp ! = Exp
    (23) Exp -> . Exp + Term
    (25) Exp -> . Term
    (24) Term -> . Term - Factor
    (26) Term -> . Term * Factor
    (27) Term -> . Term / Factor
    (28) Term -> . Factor
    (29) Factor -> . id
    (30) Factor -> . int
    (31) Factor -> . float
    (32) Factor -> . string

    id              shift and go to state 24
    int             shift and go to state 25
    float           shift and go to state 26
    string          shift and go to state 27

    Conds                          shift and go to state 71
    Cond                           shift and go to state 20
    Exp                            shift and go to state 21
    Term                           shift and go to state 22
    Factor                         shift and go to state 23

state 63

    (6) Instrucao -> if ( Conds ) { Instrucoes . }
    (7) Instrucao -> if ( Conds ) { Instrucoes . } else { Instrucoes }
    (2) Instrucoes -> Instrucoes . Instrucao
    (4) Instrucao -> . Atr
    (5) Instrucao -> . repeat { Instrucoes } until ( Conds )
    (6) Instrucao -> . if ( Conds ) { Instrucoes }
    (7) Instrucao -> . if ( Conds ) { Instrucoes } else { Instrucoes }
    (16) Atr -> . id = Exp
    (17) Atr -> . array ( id , int )
    (18) Atr -> . id [ int ] = Exp
    (19) Atr -> . id [ id ] = Exp
    (20) Atr -> . $ string
    (21) Atr -> . $ int
    (22) Atr -> . $

    }               shift and go to state 72
    repeat          shift and go to state 5
    if              shift and go to state 6
    id              shift and go to state 7
    array           shift and go to state 8
    $               shift and go to state 9

    Instrucao                      shift and go to state 10
    Atr                            shift and go to state 4

state 64

    (13) Cond -> Exp < = Exp .
    (23) Exp -> Exp . + Term

    )               reduce using rule 13 (Cond -> Exp < = Exp .)
    and             reduce using rule 13 (Cond -> Exp < = Exp .)
    +               shift and go to state 39


state 65

    (14) Cond -> Exp > = Exp .
    (23) Exp -> Exp . + Term

    )               reduce using rule 14 (Cond -> Exp > = Exp .)
    and             reduce using rule 14 (Cond -> Exp > = Exp .)
    +               shift and go to state 39


state 66

    (12) Cond -> Exp = = Exp .
    (23) Exp -> Exp . + Term

    )               reduce using rule 12 (Cond -> Exp = = Exp .)
    and             reduce using rule 12 (Cond -> Exp = = Exp .)
    +               shift and go to state 39


state 67

    (15) Cond -> Exp ! = Exp .
    (23) Exp -> Exp . + Term

    )               reduce using rule 15 (Cond -> Exp ! = Exp .)
    and             reduce using rule 15 (Cond -> Exp ! = Exp .)
    +               shift and go to state 39


state 68

    (19) Atr -> id [ id ] = Exp .
    (23) Exp -> Exp . + Term

    repeat          reduce using rule 19 (Atr -> id [ id ] = Exp .)
    if              reduce using rule 19 (Atr -> id [ id ] = Exp .)
    id              reduce using rule 19 (Atr -> id [ id ] = Exp .)
    array           reduce using rule 19 (Atr -> id [ id ] = Exp .)
    $               reduce using rule 19 (Atr -> id [ id ] = Exp .)
    $end            reduce using rule 19 (Atr -> id [ id ] = Exp .)
    }               reduce using rule 19 (Atr -> id [ id ] = Exp .)
    +               shift and go to state 39


state 69

    (18) Atr -> id [ int ] = Exp .
    (23) Exp -> Exp . + Term

    repeat          reduce using rule 18 (Atr -> id [ int ] = Exp .)
    if              reduce using rule 18 (Atr -> id [ int ] = Exp .)
    id              reduce using rule 18 (Atr -> id [ int ] = Exp .)
    array           reduce using rule 18 (Atr -> id [ int ] = Exp .)
    $               reduce using rule 18 (Atr -> id [ int ] = Exp .)
    $end            reduce using rule 18 (Atr -> id [ int ] = Exp .)
    }               reduce using rule 18 (Atr -> id [ int ] = Exp .)
    +               shift and go to state 39


state 70

    (17) Atr -> array ( id , int ) .

    repeat          reduce using rule 17 (Atr -> array ( id , int ) .)
    if              reduce using rule 17 (Atr -> array ( id , int ) .)
    id              reduce using rule 17 (Atr -> array ( id , int ) .)
    array           reduce using rule 17 (Atr -> array ( id , int ) .)
    $               reduce using rule 17 (Atr -> array ( id , int ) .)
    $end            reduce using rule 17 (Atr -> array ( id , int ) .)
    }               reduce using rule 17 (Atr -> array ( id , int ) .)


state 71

    (5) Instrucao -> repeat { Instrucoes } until ( Conds . )
    (8) Conds -> Conds . and Cond

    )               shift and go to state 73
    and             shift and go to state 34


state 72

    (6) Instrucao -> if ( Conds ) { Instrucoes } .
    (7) Instrucao -> if ( Conds ) { Instrucoes } . else { Instrucoes }

    repeat          reduce using rule 6 (Instrucao -> if ( Conds ) { Instrucoes } .)
    if              reduce using rule 6 (Instrucao -> if ( Conds ) { Instrucoes } .)
    id              reduce using rule 6 (Instrucao -> if ( Conds ) { Instrucoes } .)
    array           reduce using rule 6 (Instrucao -> if ( Conds ) { Instrucoes } .)
    $               reduce using rule 6 (Instrucao -> if ( Conds ) { Instrucoes } .)
    $end            reduce using rule 6 (Instrucao -> if ( Conds ) { Instrucoes } .)
    }               reduce using rule 6 (Instrucao -> if ( Conds ) { Instrucoes } .)
    else            shift and go to state 74


state 73

    (5) Instrucao -> repeat { Instrucoes } until ( Conds ) .

    repeat          reduce using rule 5 (Instrucao -> repeat { Instrucoes } until ( Conds ) .)
    if              reduce using rule 5 (Instrucao -> repeat { Instrucoes } until ( Conds ) .)
    id              reduce using rule 5 (Instrucao -> repeat { Instrucoes } until ( Conds ) .)
    array           reduce using rule 5 (Instrucao -> repeat { Instrucoes } until ( Conds ) .)
    $               reduce using rule 5 (Instrucao -> repeat { Instrucoes } until ( Conds ) .)
    $end            reduce using rule 5 (Instrucao -> repeat { Instrucoes } until ( Conds ) .)
    }               reduce using rule 5 (Instrucao -> repeat { Instrucoes } until ( Conds ) .)


state 74

    (7) Instrucao -> if ( Conds ) { Instrucoes } else . { Instrucoes }

    {               shift and go to state 75


state 75

    (7) Instrucao -> if ( Conds ) { Instrucoes } else { . Instrucoes }
    (2) Instrucoes -> . Instrucoes Instrucao
    (3) Instrucoes -> . Instrucao
    (4) Instrucao -> . Atr
    (5) Instrucao -> . repeat { Instrucoes } until ( Conds )
    (6) Instrucao -> . if ( Conds ) { Instrucoes }
    (7) Instrucao -> . if ( Conds ) { Instrucoes } else { Instrucoes }
    (16) Atr -> . id = Exp
    (17) Atr -> . array ( id , int )
    (18) Atr -> . id [ int ] = Exp
    (19) Atr -> . id [ id ] = Exp
    (20) Atr -> . $ string
    (21) Atr -> . $ int
    (22) Atr -> . $

    repeat          shift and go to state 5
    if              shift and go to state 6
    id              shift and go to state 7
    array           shift and go to state 8
    $               shift and go to state 9

    Instrucoes                     shift and go to state 76
    Instrucao                      shift and go to state 3
    Atr                            shift and go to state 4

state 76

    (7) Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes . }
    (2) Instrucoes -> Instrucoes . Instrucao
    (4) Instrucao -> . Atr
    (5) Instrucao -> . repeat { Instrucoes } until ( Conds )
    (6) Instrucao -> . if ( Conds ) { Instrucoes }
    (7) Instrucao -> . if ( Conds ) { Instrucoes } else { Instrucoes }
    (16) Atr -> . id = Exp
    (17) Atr -> . array ( id , int )
    (18) Atr -> . id [ int ] = Exp
    (19) Atr -> . id [ id ] = Exp
    (20) Atr -> . $ string
    (21) Atr -> . $ int
    (22) Atr -> . $

    }               shift and go to state 77
    repeat          shift and go to state 5
    if              shift and go to state 6
    id              shift and go to state 7
    array           shift and go to state 8
    $               shift and go to state 9

    Instrucao                      shift and go to state 10
    Atr                            shift and go to state 4

state 77

    (7) Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes } .

    repeat          reduce using rule 7 (Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes } .)
    if              reduce using rule 7 (Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes } .)
    id              reduce using rule 7 (Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes } .)
    array           reduce using rule 7 (Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes } .)
    $               reduce using rule 7 (Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes } .)
    $end            reduce using rule 7 (Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes } .)
    }               reduce using rule 7 (Instrucao -> if ( Conds ) { Instrucoes } else { Instrucoes } .)

